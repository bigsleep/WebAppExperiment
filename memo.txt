-------------------------------------------------------
20140223 backend

バックエンドをどう書く?

App f m a -> m a

fが決まる。mは? MonadIOとか, MonadReaderとか制約を書いておけばいいか

RunAppはより具体的なclass
どのバックエンド使うかなどを書く

class RunApp f where
    runApp :: App f IO a -> IO a

-------------------------------------------------
20140217 Logger

ログレベルは入れる
ログに吐く型 StringとかTextとかも
ファイルとかは?
設定ログレベルの取得?

ファイルに吐くならファイルパスとかの設定はどうする?
DBに吐くとかもある? ログ用APIとか
DBならDBサーバーとかDB名とか
APIならurlとか
fluentdに流すとか

JSON用のロガーとかもあるか
JSONにエンコードできれば何でも渡せるとか

data LogLevel = DEBUG | INFO | wARNING | ERROR deriving (Show, Eq, Ord, Enum)

data Logger c s =
    GetCurrentLogLevel c (LogLevel -> a) |
    Log c l s a

getCurrentLogLevel c = inject . Getcurrentloglevel c $ FreeT . return . Pure

log l c s = do
    clevel <- getcurrentloglevel c
    when (l >= c) (inject . Log c l s (FreeT . return . Pure $ ()))

logDebug = log DEBUG
logInfo = log INFO
logWarning = log WARNING
logError = log ERROR


------------------------------------------------
20140216 :<:, :+:

型引数を三つ以上とる型だと上手くいかない?
instanceがoverlapしているといわれてえらーになる

((A i o) :<: f)とかが上手くいかない

よくわからない。

型が文脈上不明な感じだったからかも。
型情報使ってる場合はセーフっぽかった
制約条件にしか現れない型が問題?
関数引数だけ足してもだめでコンストラクタにも型情報もった引数入れないとだめだった
制約条件の型変数と値のほうの型変数が一致するという情報が入ってないからのような気がする。
関数を2段階にするとかでいけるのでは

大丈夫だったコード
>||
{-# LANGUAGE TypeOperators, FlexibleContexts #-}
module Whone.WIO
() where

import Whone.Internal
import Control.Monad.Trans (lift)
import Control.Monad.Trans.Free (FreeT(..))

data Signature i o = Signature

data WIO i o a = WIO (Signature i o)

instance Functor (WIO i o) where
    fmap _ (WIO s) = (WIO s)

wio :: (Monad m, WIO i o :<: f) => Signature i o -> App f m a
wio s = App . inject $ WIO s
||<

エラー出る
>||
{-# LANGUAGE TypeOperators, FlexibleContexts #-}
module Whone.WIO
() where

import Whone.Internal
import Control.Monad.Trans (lift)
import Control.Monad.Trans.Free (FreeT(..))

data Signature i o = Signature

data WIO i o a = WIO

instance Functor (WIO i o) where
    fmap _ WIO = WIO

wio :: (Monad m, WIO i o :<: f) => App f m a
wio = App . inject $ WIO
||<

--------------------------------------------------
20140213 評価

data type a la carte のevalAlgebraとかと一緒

I aとそれぞれのInterfaceを評価用型クラスのインスタンスにして
評価用関数を適用して値を求める。
これはユーザーコードに書くか別モジュールに書くもの。
サンプル用やデバッグ用に用意するかも

data type a la carte の例をExistential Qualified Data Type で置き換えた例を書いてみる

なんか問題あるかも

Existentialにすると先に中身の性質を決めておかないといけないので
構造だけ保持して後で評価するというのには使いづらいかも

------------------------------------------------
20140212 メモ

webアプリのDSLのような感じ。
インターフェース定義とか

まずは最低限のところだけでいい

サーバーのセッティングとかは?
loadSettingを用意すればいいか
サーバーだとルーティングとかもいるのか?
ルーティングはなんか別にしたほうがいいか
Map String App とかを用意しておいてパスに応じてAPI呼ぶ感じとか
ルーティングの部分もDSLでできるか

DSLを一部使わない場合処理をスキップするような関数を用意しとくとか

実際のIOに接地させる実装は別にする
