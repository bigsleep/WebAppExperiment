------------------------------------------------
20140216 :<:, :+:

型引数を三つ以上とる型だと上手くいかない?
instanceがoverlapしているといわれてえらーになる

((A i o) :<: f)とかが上手くいかない

よくわからない。

型が文脈上不明な感じだったからかも。
型情報使ってる場合はセーフっぽかった

大丈夫だったコード
>||
{-# LANGUAGE TypeOperators, FlexibleContexts #-}
module Whone.WIO
() where

import Whone.Internal
import Control.Monad.Trans (lift)
import Control.Monad.Trans.Free (FreeT(..))

data Signature i o = Signature

data WIO i o a = WIO (Signature i o)

instance Functor (WIO i o) where
    fmap _ (WIO s) = (WIO s)

wio :: (Monad m, WIO i o :<: f) => Signature i o -> App f m a
wio s = App . inject $ WIO s
||<

エラー出る
>||
{-# LANGUAGE TypeOperators, FlexibleContexts #-}
module Whone.WIO
() where

import Whone.Internal
import Control.Monad.Trans (lift)
import Control.Monad.Trans.Free (FreeT(..))

data Signature i o = Signature

data WIO i o a = WIO

instance Functor (WIO i o) where
    fmap _ WIO = WIO

wio :: (Monad m, WIO i o :<: f) => App f m a
wio = App . inject $ WIO
||<

--------------------------------------------------
20140213 評価

data type a la carte のevalAlgebraとかと一緒

I aとそれぞれのInterfaceを評価用型クラスのインスタンスにして
評価用関数を適用して値を求める。
これはユーザーコードに書くか別モジュールに書くもの。
サンプル用やデバッグ用に用意するかも

data type a la carte の例をExistential Qualified Data Type で置き換えた例を書いてみる

なんか問題あるかも

Existentialにすると先に中身の性質を決めておかないといけないので
構造だけ保持して後で評価するというのには使いづらいかも

------------------------------------------------
20140212 メモ

webアプリのDSLのような感じ。
インターフェース定義とか

まずは最低限のところだけでいい

サーバーのセッティングとかは?
loadSettingを用意すればいいか
サーバーだとルーティングとかもいるのか?
ルーティングはなんか別にしたほうがいいか
Map String App とかを用意しておいてパスに応じてAPI呼ぶ感じとか
ルーティングの部分もDSLでできるか

DSLを一部使わない場合処理をスキップするような関数を用意しとくとか

実際のIOに接地させる実装は別にする
